/**
 * @author Gou Ming Shi
 * http://metaphy.javaeye.com/
 * Nov 23, 2009
 * All Rights Reserved
 */
package com.javaeye.metaphy.action.operation;

import static com.javaeye.metaphy.game.Game.LINEUP_FILE_EXT;

import java.awt.event.ActionEvent;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import javax.swing.JFileChooser;
import javax.swing.filechooser.FileFilter;

import com.javaeye.metaphy.action.BaseAction;
import com.javaeye.metaphy.action.operation.OperationButton.Operations;
import com.javaeye.metaphy.game.Board;
import com.javaeye.metaphy.game.BoardUtil;
import com.javaeye.metaphy.game.GamePanel;
import com.javaeye.metaphy.game.SaveLineupRadioPane;
import com.javaeye.metaphy.model.Location;

public class OperationSaveLineupFileOK extends BaseAction {
	private SaveLineupRadioPane pan = null;

	public OperationSaveLineupFileOK(SaveLineupRadioPane pan) {
		this.pan = pan;
	}

	/*
	 * Display the Radio-Panel
	 */
	public void actionPerformed(ActionEvent e) {
		GamePanel panel = game.getPanel();
		// Open file chooser
		JFileChooser chooser = new JFileChooser();
		chooser.setFileFilter(new LineupFileFilter());
		chooser.setSelectedFile(new File("Noname1" + LINEUP_FILE_EXT));
		int result = chooser.showSaveDialog(game.getContainer());

		if (result == JFileChooser.APPROVE_OPTION) {
			File f = chooser.getSelectedFile();
			if (f != null) {
				String filePathName = f.getPath();

				if (!filePathName.endsWith(LINEUP_FILE_EXT)) {
					filePathName = filePathName + LINEUP_FILE_EXT;
				}

				f = new File(filePathName);
				FileOutputStream fos = null;
				try {
					fos = new FileOutputStream(f);
					// Write the generated output stream bytes
					fos.write(outputStreamBytes());
					fos.close();
				} catch (IOException e1) {
					e1.printStackTrace();
				} finally {
					try {
						fos.close();
					} catch (IOException e1) {
						e1.printStackTrace();
					}
				}

				// Hide this panel
				panel.getSaveLineupRadioPane().setVisible(false);

				// Show/Hide other Operation buttons
				panel.viewAllOpButtons(true);
				panel.viewOneOpButton(Operations.GIVE_UP, false);
				panel.viewOneOpButton(Operations.PASS, false);
			}
		}
	}

	/**
	 * Generate the output stream bytes
	 * 
	 * @return
	 */
	private byte[] outputStreamBytes() {
		Board gameBoard = game.getGameBoard();
		byte[] bytes = new byte[50];
		/*
		 * The first 16 bytes in ASCII are "Generated by MC" & 0x00
		 */
		bytes[0] = 0x47;
		bytes[1] = 0x65;
		bytes[2] = 0x6E;
		bytes[3] = 0x65;
		bytes[4] = 0x72;
		bytes[5] = 0x61;
		bytes[6] = 0x74;
		bytes[7] = 0x65;
		bytes[8] = 0x64;
		bytes[9] = 0x20;
		bytes[10] = 0x62;
		bytes[11] = 0x79;
		bytes[12] = 0x20;
		bytes[13] = 0x4D;
		bytes[14] = 0x43;
		bytes[15] = 0x00;

		bytes[16] = 0x57; // W
		bytes[17] = 0x04; // EOT - End of transmission
		bytes[18] = 0x00;
		bytes[19] = 0x00;

		int index = 20;

		if (pan.getLocSelected() == Location.NORTH) {
			// 限制对board数组取值区域
			for (int j = 5; j >= 0; j--) {
				for (int i = 10; i >= 6; i--) {
					if (gameBoard.getBoard()[i][j] == BoardUtil.INVALID) {
						bytes[index++] = BoardUtil.INVALID;
					} else {
						bytes[index++] = (byte) ((int) gameBoard.getBoard()[i][j] - 16);
					}
				}
			}
		} else if (pan.getLocSelected() == Location.SOUTH) {
			for (int j = 11; j <= 16; j++) {
				for (int i = 6; i <= 10; i++) {
					bytes[index++] = gameBoard.getBoard()[i][j];
				}
			}
		} else if (pan.getLocSelected() == Location.WEST) {
			for (int i = 5; i >= 0; i--) {
				for (int j = 6; j <= 10; j++) {
					if (gameBoard.getBoard()[i][j] == BoardUtil.INVALID) {
						bytes[index++] = BoardUtil.INVALID;
					} else {
						bytes[index++] = (byte) ((int) gameBoard.getBoard()[i][j] - 16 * 2);
					}
				}
			}
		} else if (pan.getLocSelected() == Location.EAST) {
			for (int i = 11; i <= 16; i++) {
				for (int j = 10; j >= 6; j--) {
					if (gameBoard.getBoard()[i][j] == BoardUtil.INVALID) {
						bytes[index++] = BoardUtil.INVALID;
					} else {
						bytes[index++] = (byte) ((int) gameBoard.getBoard()[i][j] - 16 * 3);
					}
				}

			}
		}
		return bytes;
	}

	/*
	 * Filter of the lineup files
	 */
	private class LineupFileFilter extends FileFilter {
		@Override
		public boolean accept(File f) {
			return f.getName().toLowerCase().endsWith(LINEUP_FILE_EXT)
					|| f.isDirectory();
		}

		@Override
		public String getDescription() {
			return LINEUP_FILE_EXT.replace(".", "");
		}

	}
}
